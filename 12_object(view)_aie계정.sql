/*
    뷰 VIEW
    SELECT문을 저장해둘 수 있는 객체
    => 자주 쓰는 긴 SELECT문을 저장해둔다 든지에 씀
    
    CREATE VIEW 뷰명
    AS 서브쿼리문;
*/

SELECT *
FROM EMPLOYEE, LOCATION L, NATIONAL N, DEPARTMENT 
WHERE DEPT_CODE = DEPT_ID AND LOCATION_ID = LOCAL_CODE AND L.NATIONAL_CODE = N.NATIONAL_CODE
AND NATIONAL_NAME = '한국';

CREATE VIEW VM_EMPLOYEE
AS SELECT *
FROM EMPLOYEE, LOCATION L, NATIONAL N, DEPARTMENT 
WHERE DEPT_CODE = DEPT_ID AND LOCATION_ID = LOCAL_CODE AND L.NATIONAL_CODE = N.NATIONAL_CODE;

CREATE VIEW VIEW_EMPLOYEE
AS SELECT * 
FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE
JOIN NATIONAL USING(NATIONAL_CODE);

GRANT CREATE VIEW TO aie;

SELECT * FROM VIEW_EMPLOYEE WHERE NATIONAL_NAME = '한국';

SELECT * FROM USER_VIEWS;

// VIEW 컬럼에 별칭 부여
// 서브쿼리의 SELECT절에 함수식이나 산술연산식이 기술되어있을 경우 반드시 별칭 지정
// CREATE OR REPLACE VIEW 뷰명 => 같은 명칭의 VIEW가 있으면 덮어쓰기

SELECT EMP_ID 사원번호,EMP_NAME 사원명,JOB_NAME 직급명,DECODE(SUBSTR(EMP_NO, 8, 1), '1','남자', '2','여자', '3','남자', '4','여자') 성별, EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM HIRE_DATE) 근무년수
FROM EMPLOYEE JOIN JOB USING(JOB_CODE) ORDER BY 1;

CREATE OR REPLACE VIEW VM_EMP 
AS SELECT EMP_ID 사원번호,EMP_NAME 사원명,JOB_NAME 직급명,DECODE(SUBSTR(EMP_NO, 8, 1), '1','남자', '2','여자', '3','남자', '4','여자') 성별, ROUND(MONTHS_BETWEEN(SYSDATE,HIRE_DATE)/12) 근무년수
FROM EMPLOYEE JOIN JOB USING(JOB_CODE);

SELECT * FROM VM_EMP ORDER BY 1;

//별칭 이렇게도 부여가능
CREATE VIEW VM_EMP_JOB(사번, 사원명, 직급명, 성별, 극무년수) 
AS SELECT EMP_ID,EMP_NAME,JOB_NAME,DECODE(SUBSTR(EMP_NO, 8, 1), '1','남자', '2','여자', '3','남자', '4','여자'), EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM HIRE_DATE)
FROM EMPLOYEE JOIN JOB USING(JOB_CODE) ORDER BY 1;

SELECT * FROM VM_EMP_JOB;

SELECT 사원명,직급명,성별
FROM VM_EMP_JOB
WHERE 성별 = '여자';

SELECT 사원명,직급명,성별
FROM VM_EMP_JOB
WHERE 극무년수 >= 20;

DROP VIEW VM_EMP_JOB; // VIEW 삭제

//생선된 뷰를 이용하여 DML(INSERT,UPDATE,DELETE) 가능
// 뷰룰 통해 조작하면 실제 데이터가 담겨있는 베이스 테이블에 반영됨

CREATE VIEW VM_JOB
AS SELECT * FROM JOB;

INSERT INTO VM_JOB VALUES('J8','인턴'); //추가

UPDATE VM_JOB SET JOB_NAME = 'INTERN' WHERE JOB_CODE = 'J8'; //업데이트

DELETE FROM VM_JOB WHERE JOB_CODE = 'J8'; // 삭제

SELECT * FROM VM_JOB ORDER BY 1;

/* BUT, DML 명령어로 조작이 불가능한 경우가 더 多
    => 상식적으로 안될꺼 같은거 안하면됨
    1. 뷰에 정의되어 있지 않은 컬럼 조작하려는 경우
    2. 뷰에 정의되어 있는 컬럼 중에 베이스테이블 상에 NOT NULL제약조건이 지정되어있는 경우
    3. 산술연산식이나 함수식으로 정의되어 있는 경우
    4. 그룹함수나 GROUP BY절이 포함되어 있는 경우
    5. DISTINCT 구문이 포함되어 있는 경우
    6. JOIN을 이용하여 여러 테이블을 연결시켜놓은 경우
*/

//1. 뷰에 정의되어 있지 않은 컬럼 조작하려는 경우
CREATE OR REPLACE VIEW VM_JOB
AS SELECT JOB_CODE FROM JOB;

SELECT JOB_NAME FROM VM_JOB;

// 2. 뷰에 정의되어 있는 컬럼 중에 베이스테이블 상에 NOT NULL제약조건이 지정되어있는 경우
CREATE VIEW VM_JOB_NAME
AS SELECT JOB_NAME FROM JOB;

INSERT INTO VM_JOB_NAME VALUES('사원'); --> JOBCODE가 PK(PRIMARY KEY) 이므로 무조건 넣어야됨 (NOT NULL)

//3. 산술연산식이나 함수식으로 정의되어 있는 경우
CREATE VIEW VM_EMP_SAL 
AS SELECT EMP_ID,EMP_NAME,SALARY,SALARY*12 연봉 FROM EMPLOYEE;

INSERT INTO VM_EMP_SAL VALUES(600,'김이박','3000000','36000000'); //연봉이 없으므로 사용 못함(가상테이블)
INSERT INTO VM_EMP_SAL VALUES(600,'김이박','3000000'); //NOT NULL 때문에 안됨

UPDATE VM_EMP_SAL SET 연봉 = '48000000' WHERE EMP_ID = 301;

SELECT * FROM VM_EMP_SAL ORDER BY 연봉;

DELETE FROM VM_EMP_SAL WHERE 연봉 = '16560000'; //성공 -> 이렇게는 삭제가능

ROLLBACK;

//4. 그룹함수나 GROUP BY절이 포함되어 있는 경우
CREATE OR REPLACE VIEW VM_EMP_DP
AS SELECT DEPT_CODE,  ROUND(AVG(SALARY)) 평균, SUM(SALARY)  합계 FROM EMPLOYEE GROUP BY DEPT_CODE;

SELECT * FROM VM_EMP_DP;

INSERT INTO VM_EMP_DP VALUES('D3',10000000, 10000000); //NOT NULL 때문에 

//5. DISTINCT 구문이 포함되어 있는 경우

CREATE OR REPLACE VIEW VM_JOB
AS SELECT DISTINCT JOB_CODE FROM EMPLOYEE;

SELECT * FROM VM_JOB;

UPDATE VM_JOB SET JOB_CODE  = 'J8' WHERE JOB_CODE IS NULL;

DELETE FROM VM_JOB WHERE JOB_CODE = 'J1'; // DISTINT 있어서 그럼


// 6. JOIN을 이용하여 여러 테이블을 연결시켜놓은 경우
CREATE OR REPLACE VIEW VM_JOIN
AS SELECT EMP_ID,EMP_NAME,DEPT_TITLE FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID;

SELECT * FROM VM_JOIN ORDER BY 1;

INSERT INTO VM_JOIN VALUES(700,'DDD','');  // JOIN된거라서 두 개 다 넣을 수 없음

--------------------------------------------------------------------------------
/*
    * VIEW 옵션
    [표현식] 
    CREATE [OR REPLACE] [FORCE | NOFORCE] VIEW 뷰명 
    AS 서브쿼리
    [WITH CHECK OPTION]
    [WITH READ ONLY];
    
    1) OR REPLACE : 기존에 동일 뷰가 있으면 갱신시키고, 없으면 새로 생성
    2) FORCE | NOFORCE
        > FORCE : 서브쿼리에 기술된 테이블이 존재하지 않다도 뷰가 생성됨
        > NOFORCE : 서브쿼리에 기술된 테이블이 존재해야만 뷰를 생성할 수 있음(생략시 기본값)
    3) WITH CHECK OPTION : DML시 서브쿼리에 기술된 조건에 부합하는 값으로만 DML이 가능하도록 함
    4) WITH READ ONLY : 뷰에 대해 조회만 가능(DML문(SELECT제외) 불가)
*/
-- 2) FORCE | NOFORCE
--      NOFORCE
CREATE OR REPLACE /* NOFORCE */ VIEW VM_EMP
AS SELECT TCODE, TNAME, TCOUNT
        FROM TT;

--      FORCE
CREATE OR REPLACE FORCE VIEW VM_EMP
AS SELECT TCODE, TNAME, TCOUNT
        FROM TT;
        
SELECT * FROM VM_EMP;

--    TT테이블을 생성해야만 그때부터 VIEW활용
CREATE TABLE TT (
    TCODE NUMBER,
    TNAME VARCHAR2(20),
    TCOUNT NUMBER
);

SELECT * FROM VM_EMP;

--  3) WITH CHECK OPTION

--==   옵션없이 그냥 VIEW 생성
CREATE OR REPLACE VIEW VM_EMP
AS SELECT *
        FROM EMPLOYEE
     WHERE SALARY >= 3000000;   

SELECT * FROM VM_EMP;   -- 8명 조회

-- 200번 사원의 급여를 200만원으로 변경
UPDATE VM_EMP
    SET SALARY = 2000000
WHERE EMP_ID = 200;      

SELECT * FROM VM_EMP;   -- 7명 조회

--==   WITH CHECK OPTION을 써서 생성
CREATE OR REPLACE VIEW VM_EMP_CHECK
AS SELECT *
        FROM EMPLOYEE
     WHERE SALARY >= 3000000
WITH CHECK OPTION;     

-- 오류 : 서브쿼리에 기술된 조건에 부합되지 않기 때문에 변경불가
UPDATE VM_EMP_CHECK
        SET SALARY = 2000000
WHERE EMP_ID = 201;        

UPDATE VM_EMP_CHECK  -- 성공
        SET SALARY = 4000000
WHERE EMP_ID = 202;

-- 4) WITH READ ONLY 
CREATE OR REPLACE VIEW VM_EMP_READ
AS SELECT EMP_ID, EMP_NAME, BONUS
        FROM EMPLOYEE
      WHERE BONUS IS NOT NULL
WITH READ ONLY;   

SELECT * FROM VM_EMP_READ;  -- 검색만 가능

DELETE FROM VM_EMP_READ WHERE EMP_ID = 200;  -- 오류