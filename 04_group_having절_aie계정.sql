/*
    GROUP BY
    그룹기주을 제시할 수 있는 구문(여러 그룹기준별로 여러 그룹으로 묶을 수 있음)
    여러개의 값들을 하나의 그룹으로 묶어서 처리 할 목적으로 사용
*/

SELECT SUM(SALARY) FROM EMPLOYEE; // 전체 사원을 하나의 그룹으로 묶어서 총합

SELECT DEPT_CODE 부서별, SUM(SALARY) 급여합계 FROM EMPLOYEE GROUP BY DEPT_CODE;

SELECT DEPT_CODE 부서별, COUNT(*) 사원수,SUM(SALARY) 급여합계 FROM EMPLOYEE GROUP BY DEPT_CODE;

SELECT JOB_CODE 직급별, COUNT(*) "총 사원수",COUNT(BONUS) "보너스 받는 사원수",SUM(SALARY) "급여 합계",ROUND(AVG(SALARY),-1) "평균급여",MIN(SALARY) "최저급여",MAX(SALARY) "최고급여"
FROM EMPLOYEE GROUP BY JOB_CODE ORDER BY 1;

/*
    HAING
    그룹에 대한 조건을 제시 할 때 사용되는 구문(주로 그룹함수식을 가지고 조건을 제시할 때 사용)
*/
SELECT DEPT_CODE, CEIL(AVG(SALARY)) AS "평균급여"
FROM EMPLOYEE
GROUP BY DEPT_CODE HAVING AVG(SALARY) >= 3000000 ORDER BY 1;


/* 문제 */
SELECT JOB_CODE, SUM(SALARY) 
FROM EMPLOYEE
GROUP BY JOB_CODE HAVING SUM(SALARY) >= 10000000 ORDER BY 1;

SELECT DEPT_CODE
FROM EMPLOYEE
WHERE BONUS IS NOT NULL
GROUP BY DEPT_CODE ;

SELECT DEPT_CODE
FROM EMPLOYEE
GROUP BY DEPT_CODE HAVING COUNT(BONUS) = 0
ORDER BY 1;

/*
    ROLLUP(컬럼1,컬럼2) : 컬럼1을 가지고 다시 중간집계를 내는 함수
    CUBE(컬럼1,컬럼2) : 컬럼1을 가지고 다시 중간집계를 내고 컬럼2를 다시 중간집계를 내는 함수
*/

SELECT JOB_CODE,DEPT_CODE,SUM(SALARY)
FROM EMPLOYEE
GROUP BY CUBE(JOB_CODE,DEPT_CODE) ORDER BY 1;

SELECT JOB_CODE,DEPT_CODE,SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(JOB_CODE,DEPT_CODE) ORDER BY 1;

/*
    집합연산자 == SET OPERATION
    여러개의 쿼리문을 가지고 하나의 쿼리문으로 만드는 연산자
    
    UNION  or OR (합집합 => 두 쿼리문 중 중복값 한나만)
    INTERSECT or AND (교집합 => 중복값만 보임)
    UNION ALL : 합집합 + 교집합 => 중복되는 값 두번 표현 (다 보여주는거)
    MINUS : 차집합(두 집합 중 중복값 빼고)
*/

SELECT EMP_NAME,DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION 
SELECT EMP_NAME,DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE SALARY > 300000; 

SELECT EMP_NAME,DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5' OR SALARY > 300000; 

SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
MINUS
SELECT *
FROM EMPLOYEE
WHERE SALARY > 3000000;
// 제외
